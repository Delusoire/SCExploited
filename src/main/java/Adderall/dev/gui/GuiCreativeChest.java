package Adderall.dev.gui;

import net.geforcemods.securitycraft.network.packets.PacketSSyncTENBTTag;
import net.minecraft.client.gui.GuiButton;
import net.minecraft.client.gui.GuiTextField;
import net.minecraft.client.gui.inventory.GuiContainer;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.InventoryPlayer;
import net.minecraft.inventory.Container;
import net.minecraft.inventory.IInventory;
import net.minecraft.inventory.InventoryBasic;
import net.minecraft.inventory.Slot;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.ResourceLocation;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.GL11;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import static Adderall.dev.util.Network.sendPacket2SC;

public class GuiCreativeChest extends GuiContainer {

    private int currentScroll = 0;

    private final ResourceLocation background = new ResourceLocation("textures/gui/container/generic_54.png");

    private GuiTextField searchField;

    public GuiCreativeChest(final TileEntity tileEntityInv) { super(new ContainerCreativeChest(tileEntityInv)); }

    public ContainerCreativeChest getInvSlots() {
        return (ContainerCreativeChest) inventorySlots;
    }

    @Override
    protected void drawGuiContainerForegroundLayer(int mouseX, int mouseY) {
        super.drawGuiContainerForegroundLayer(mouseX, mouseY);
        int n = getInvSlots().fakeInvSize;

        GL11.glDisable(GL11.GL_LIGHTING);
        GL11.glDisable(GL11.GL_DEPTH_TEST);
        GL11.glColorMask(true, true, true, false);
        while (n < ContainerCreativeChest.fakeInvNbTotal) {
            Slot slot = getInvSlots().getSlot(n);
            int x = slot.xDisplayPosition;
            int y = slot.yDisplayPosition;
            drawGradientRect(x, y, x + 16, y + 16, 1694433280, 1694433280);
            n++;
        }
        GL11.glColorMask(true, true, true, true);
        GL11.glEnable(GL11.GL_LIGHTING);
        GL11.glEnable(GL11.GL_DEPTH_TEST);

        searchField.drawTextBox();
    }

    @Override
    protected void drawGuiContainerBackgroundLayer(float partialTicks, int mouseX, int mouseY) {
        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
        mc.getTextureManager().bindTexture(background);
        drawTexturedModalRect(guiLeft, guiTop - 8, 0, 10, xSize + 10, ContainerCreativeChest.fakeInvNbRows * 18 + 13);
    }

    @Override
    public void initGui() {
        xSize = ContainerCreativeChest.nbColumns * 18 + 15;
        ySize = (ContainerCreativeChest.nbRows + ContainerCreativeChest.fakeInvNbRows) * 18 + 15;
        super.initGui();

        searchField = new GuiTextField(fontRendererObj,
                (xSize - 89) / 2, (ContainerCreativeChest.fakeInvNbRows + 1) * 18,
                89, fontRendererObj.FONT_HEIGHT);

        searchField.setMaxStringLength(14);
        searchField.setEnableBackgroundDrawing(false);
        searchField.setTextColor(16777215);
        searchField.setVisible(true);
        searchField.setCanLoseFocus(false);
        searchField.setFocused(true);
        searchField.setText("");

        Keyboard.enableRepeatEvents(false);
        buttonList.clear();
        GuiButton button_sync = new GuiButton(0, (width - 40) / 2, guiTop - 30, 40, 20, "Sync");
        button_sync.enabled = true;
        buttonList.add(button_sync);
    }

    @Override
    protected void keyTyped(char typedChar, int keyCode) {
        if (searchField.textboxKeyTyped(typedChar, keyCode)) updateFilteredItems();
        else super.keyTyped(typedChar, keyCode);
    }

    public void handleMouseInput()
    {
        super.handleMouseInput();
        int i = Mouse.getEventDWheel();

        if (i != 0)
        {
            int m = (int) Math.ceil((float) getInvSlots().itemList.size() / ContainerCreativeChest.nbColumns) - ContainerCreativeChest.nbRows;

            currentScroll = m > 0 ? Math.max(0, Math.min(currentScroll - (i > 0 ? 1 : -1), m)) : 0;

            getInvSlots().scrollTo(currentScroll);
        }
    }

    @Override
    protected void handleMouseClick(Slot slotIn, int slotId, int clickedButton, int clickType) {
        if (slotId >= ContainerCreativeChest.fakeInvNbTotal) {
            if (slotIn != null) {
                ItemStack isInSlot = slotIn.getStack();
                if (isInSlot != null) {
                    InventoryPlayer inv = mc.thePlayer.inventory;
                    inv.setItemStack(ItemStack.copyItemStack(isInSlot));
                    ItemStack is = inv.getItemStack();
                    is.stackSize = is.getMaxStackSize();
                }
            }
        } else if (slotId < getInvSlots().fakeInvSize) {
            mc.thePlayer.openContainer.slotClick(slotIn == null ? slotId : slotIn.slotNumber,
                    clickedButton, clickType, mc.thePlayer);
        }
    }

    private void updateFilteredItems() {
        getInvSlots().refetchItems();

        Iterator iterator = getInvSlots().itemList.iterator();
        String s1 = searchField.getText().toLowerCase();

        while (iterator.hasNext())
        {
            ItemStack itemstack = (ItemStack)iterator.next();
            boolean flag = false;
            Iterator iterator1 = itemstack.getTooltip(mc.thePlayer, mc.gameSettings.advancedItemTooltips).iterator();

            while (true)
            {
                if (iterator1.hasNext())
                {
                    String s = (String)iterator1.next();
                    if (!s.toLowerCase().contains(s1)) continue;
                    flag = true;
                }

                if (!flag) iterator.remove();

                break;
            }
        }

        getInvSlots().scrollTo(currentScroll = 0);
    }

    @Override
    protected void actionPerformed(GuiButton button) {
        if (button.id == 0) {
            NBTTagCompound nbt = new NBTTagCompound();
            TileEntity te = getInvSlots().tileEntity;
            te.writeToNBT(nbt);
            sendPacket2SC(new PacketSSyncTENBTTag(te.xCoord, te.yCoord, te.zCoord, nbt));
        }
    }

    static class ContainerCreativeChest extends Container {

        public List itemList = new ArrayList();

        public static int nbColumns = 9;
        public static int nbRows = 10;
        public static int nbTotal = nbColumns * nbRows;
        private static final InventoryBasic all_items = new InventoryBasic("tmp", true, nbTotal);

        public static int fakeInvNbRows = 6;
        public static int fakeInvNbTotal = nbColumns * fakeInvNbRows;
        public int fakeInvSize;
        private final TileEntity tileEntity;

        public ContainerCreativeChest(final TileEntity tileEntityInv) {
            tileEntity = tileEntityInv;
            IInventory fakeInv = (IInventory) tileEntityInv;
            fakeInv.openChest();

            int n = 0;
            int column = 0, row = 0;

            fakeInvSize = Math.min(fakeInv.getSizeInventory(), fakeInvNbTotal);
            while (n < fakeInvNbTotal) {
                addSlotToContainer(new Slot(n < fakeInvSize ? fakeInv : NullIInventory.INSTANCE, n, column * 18 + 8, row * 18));
                n++;
                column = n % nbColumns;
                if (column == 0) row++;
            }

            for (int r = 0; r < nbRows; r++)
                for (int c = 0; c < nbColumns; c++)
                    addSlotToContainer(new Slot(all_items, c + r * nbColumns, c * 18 + 8, r * 18 + 146));

            refetchItems();
            scrollTo(0);
        }

        public void refetchItems() {
            itemList.clear();
            for (Object o : Item.itemRegistry) {
                Item item = (Item) o;
                if (item != null)
                    item.getSubItems(item, null, itemList);
            }
        }

        @Override
        public void onContainerClosed(EntityPlayer p_75134_1_) {
            ((IInventory) tileEntity).closeChest();
        }

        public void scrollTo(float p)
        {
            int j = Math.max(0, (int) Math.ceil(p));

            for (int c = 0; c < nbColumns; c++)
                for (int r = 0; r < nbRows; r++) {
                    int i1 = (r + j) * nbColumns + c;
                    all_items.setInventorySlotContents(r * nbColumns + c,
                            0 <= i1 && i1 < itemList.size() ? (ItemStack) itemList.get(i1) : null);
                }
        }

        @Override
        public boolean canInteractWith(EntityPlayer player) {
            return true;
        }
    }

    static class NullIInventory implements IInventory {

        static NullIInventory INSTANCE = new NullIInventory();

        @Override
        public int getSizeInventory() { return 0; }

        @Override
        public ItemStack getStackInSlot(int slotIn) { return null; }

        @Override
        public ItemStack decrStackSize(int index, int count) { return null; }

        @Override
        public ItemStack getStackInSlotOnClosing(int index) { return null; }

        @Override
        public void setInventorySlotContents(int index, ItemStack stack) {}

        @Override
        public String getInventoryName() { return null; }

        @Override
        public boolean isCustomInventoryName() { return false; }

        @Override
        public int getInventoryStackLimit() { return 0; }

        @Override
        public void markDirty() { }

        @Override
        public boolean isUseableByPlayer(EntityPlayer player) { return false; }

        @Override
        public void openChest() { }

        @Override
        public void closeChest() { }

        @Override
        public boolean isItemValidForSlot(int index, ItemStack stack) { return false; }
    }
}
